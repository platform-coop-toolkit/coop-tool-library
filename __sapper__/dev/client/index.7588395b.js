import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, g as globals, a as validate_each_argument, e as element, t as text, b as space, c as claim_element, f as children, h as claim_text, j as detach_dev, k as claim_space, l as attr_dev, m as add_location, n as insert_dev, o as append_dev, p as destroy_each, q as set_data_dev, r as svg_element, u as noop, w as createEventDispatcher, x as run_all, y as listen_dev, z as create_component, A as claim_component, B as mount_component, C as transition_in, D as transition_out, E as destroy_component, F as group_outros, G as check_outros, H as query_selector_all } from './client.e6f1f435.js';

/* src/components/Card.svelte generated by Svelte v3.22.2 */

const { Object: Object_1 } = globals;
const file = "src/components/Card.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (22:8) {#if tool.niches }
function create_if_block_5(ctx) {
	let div;
	let span;
	let t0;
	let t1;
	let each_value = Object.keys(/*tool*/ ctx[0].niches);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			t0 = text("tool type:");
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "tool type:");
			span_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "screen-reader-text");
			add_location(span, file, 22, 32, 637);
			attr_dev(div, "class", "card__meta");
			add_location(div, file, 22, 8, 613);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			append_dev(span, t0);
			append_dev(div, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*tool, Object*/ 1) {
				each_value = Object.keys(/*tool*/ ctx[0].niches);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(22:8) {#if tool.niches }",
		ctx
	});

	return block;
}

// (25:21) {#if tool.niches[niche].length > 0}
function create_if_block_6(ctx) {
	let t0;
	let t1_value = /*tool*/ ctx[0].niches[/*niche*/ ctx[1]].map(func).join(", ") + "";
	let t1;

	const block = {
		c: function create() {
			t0 = text(": ");
			t1 = text(t1_value);
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, ": ");
			t1 = claim_text(nodes, t1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*tool*/ 1 && t1_value !== (t1_value = /*tool*/ ctx[0].niches[/*niche*/ ctx[1]].map(func).join(", ") + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(25:21) {#if tool.niches[niche].length > 0}",
		ctx
	});

	return block;
}

// (24:8) {#each Object.keys(tool.niches) as niche}
function create_each_block(ctx) {
	let t_value = /*niche*/ ctx[1] + "";
	let t;
	let br;
	let if_block = /*tool*/ ctx[0].niches[/*niche*/ ctx[1]].length > 0 && create_if_block_6(ctx);

	const block = {
		c: function create() {
			t = text(t_value);
			if (if_block) if_block.c();
			br = element("br");
			this.h();
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
			if (if_block) if_block.l(nodes);
			br = claim_element(nodes, "BR", {});
			this.h();
		},
		h: function hydrate() {
			add_location(br, file, 24, 130, 869);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, br, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*tool*/ 1 && t_value !== (t_value = /*niche*/ ctx[1] + "")) set_data_dev(t, t_value);

			if (/*tool*/ ctx[0].niches[/*niche*/ ctx[1]].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					if_block.m(br.parentNode, br);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(24:8) {#each Object.keys(tool.niches) as niche}",
		ctx
	});

	return block;
}

// (29:8) {#if tool.useCount > 0}
function create_if_block_4(ctx) {
	let div;
	let t0_value = /*tool*/ ctx[0].usecount + "";
	let t0;
	let t1;
	let t2_value = (/*tool*/ ctx[0].usecount > 1 ? "coops use" : "coop uses") + "";
	let t2;
	let t3;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
			t3 = text(" it");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			t2 = claim_text(div_nodes, t2_value);
			t3 = claim_text(div_nodes, " it");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "card__meta");
			add_location(div, file, 29, 8, 961);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);
			append_dev(div, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*tool*/ 1 && t0_value !== (t0_value = /*tool*/ ctx[0].usecount + "")) set_data_dev(t0, t0_value);
			if (dirty & /*tool*/ 1 && t2_value !== (t2_value = (/*tool*/ ctx[0].usecount > 1 ? "coops use" : "coop uses") + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(29:8) {#if tool.useCount > 0}",
		ctx
	});

	return block;
}

// (32:8) {#if tool.pricing }
function create_if_block_3(ctx) {
	let div;
	let svg;
	let use;
	let t0;
	let t1_value = /*tool*/ ctx[0].pricing + "";
	let t1;

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			use = svg_element("use");
			t0 = text(" Pricing: ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			svg = claim_element(
				div_nodes,
				"svg",
				{
					class: true,
					viewBox: true,
					"aria-hidden": true,
					focusable: true
				},
				1
			);

			var svg_nodes = children(svg);
			use = claim_element(svg_nodes, "use", { href: true }, 1);
			children(use).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			t0 = claim_text(div_nodes, " Pricing: ");
			t1 = claim_text(div_nodes, t1_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(use, "href", "/images/report.svg#report");
			add_location(use, file, 32, 120, 1224);
			attr_dev(svg, "class", "icon icon--report");
			attr_dev(svg, "viewBox", "0 0 20 20");
			attr_dev(svg, "aria-hidden", "true");
			attr_dev(svg, "focusable", "false");
			add_location(svg, file, 32, 32, 1136);
			attr_dev(div, "class", "card__meta");
			add_location(div, file, 32, 8, 1112);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, use);
			append_dev(div, t0);
			append_dev(div, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*tool*/ 1 && t1_value !== (t1_value = /*tool*/ ctx[0].pricing + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(32:8) {#if tool.pricing }",
		ctx
	});

	return block;
}

// (35:8) {#if tool.license }
function create_if_block_2(ctx) {
	let div;
	let svg;
	let use;
	let t0;
	let t1_value = /*tool*/ ctx[0].license + "";
	let t1;

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			use = svg_element("use");
			t0 = text(" Licensing: ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			svg = claim_element(
				div_nodes,
				"svg",
				{
					class: true,
					viewBox: true,
					"aria-hidden": true,
					focusable: true
				},
				1
			);

			var svg_nodes = children(svg);
			use = claim_element(svg_nodes, "use", { href: true }, 1);
			children(use).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			t0 = claim_text(div_nodes, " Licensing: ");
			t1 = claim_text(div_nodes, t1_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(use, "href", "/images/settings.svg#settings");
			add_location(use, file, 35, 122, 1467);
			attr_dev(svg, "class", "icon icon--settings");
			attr_dev(svg, "viewBox", "0 0 20 20");
			attr_dev(svg, "aria-hidden", "true");
			attr_dev(svg, "focusable", "false");
			add_location(svg, file, 35, 32, 1377);
			attr_dev(div, "class", "card__meta");
			add_location(div, file, 35, 8, 1353);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, use);
			append_dev(div, t0);
			append_dev(div, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*tool*/ 1 && t1_value !== (t1_value = /*tool*/ ctx[0].license + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(35:8) {#if tool.license }",
		ctx
	});

	return block;
}

// (38:8) {#if tool.sectors && tool.sectors.length > 0 }
function create_if_block_1(ctx) {
	let div;
	let svg;
	let use;
	let t0;
	let t1_value = fancyConcat(/*tool*/ ctx[0].sectors) + "";
	let t1;

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			use = svg_element("use");
			t0 = text(" Sector: ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			svg = claim_element(
				div_nodes,
				"svg",
				{
					class: true,
					viewBox: true,
					"aria-hidden": true,
					focusable: true
				},
				1
			);

			var svg_nodes = children(svg);
			use = claim_element(svg_nodes, "use", { href: true }, 1);
			children(use).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			t0 = claim_text(div_nodes, " Sector: ");
			t1 = claim_text(div_nodes, t1_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(use, "href", "/images/sector.svg#sector");
			add_location(use, file, 38, 120, 1741);
			attr_dev(svg, "class", "icon icon--sector");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "aria-hidden", "true");
			attr_dev(svg, "focusable", "false");
			add_location(svg, file, 38, 32, 1653);
			attr_dev(div, "class", "card__meta");
			add_location(div, file, 38, 8, 1629);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, use);
			append_dev(div, t0);
			append_dev(div, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*tool*/ 1 && t1_value !== (t1_value = fancyConcat(/*tool*/ ctx[0].sectors) + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(38:8) {#if tool.sectors && tool.sectors.length > 0 }",
		ctx
	});

	return block;
}

// (41:8) {#if tool.languages && tool.languages.length > 0 }
function create_if_block(ctx) {
	let div;
	let svg;
	let use;
	let t0;
	let t1_value = fancyConcat(/*tool*/ ctx[0].languages) + "";
	let t1;

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			use = svg_element("use");
			t0 = text(" Language: ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			svg = claim_element(
				div_nodes,
				"svg",
				{
					class: true,
					viewBox: true,
					"aria-hidden": true,
					focusable: true
				},
				1
			);

			var svg_nodes = children(svg);
			use = claim_element(svg_nodes, "use", { href: true }, 1);
			children(use).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			t0 = claim_text(div_nodes, " Language: ");
			t1 = claim_text(div_nodes, t1_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(use, "href", "/images/info.svg#info");
			add_location(use, file, 41, 118, 2023);
			attr_dev(svg, "class", "icon icon--info");
			attr_dev(svg, "viewBox", "0 0 20 20");
			attr_dev(svg, "aria-hidden", "true");
			attr_dev(svg, "focusable", "false");
			add_location(svg, file, 41, 32, 1937);
			attr_dev(div, "class", "card__meta");
			add_location(div, file, 41, 8, 1913);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, use);
			append_dev(div, t0);
			append_dev(div, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*tool*/ 1 && t1_value !== (t1_value = fancyConcat(/*tool*/ ctx[0].languages) + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(41:8) {#if tool.languages && tool.languages.length > 0 }",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let article;
	let header;
	let h2;
	let a;
	let t0_value = /*tool*/ ctx[0].name + "";
	let t0;
	let a_href_value;
	let t1;
	let div;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let article_data_niche_value;
	let if_block0 = /*tool*/ ctx[0].niches && create_if_block_5(ctx);
	let if_block1 = /*tool*/ ctx[0].useCount > 0 && create_if_block_4(ctx);
	let if_block2 = /*tool*/ ctx[0].pricing && create_if_block_3(ctx);
	let if_block3 = /*tool*/ ctx[0].license && create_if_block_2(ctx);
	let if_block4 = /*tool*/ ctx[0].sectors && /*tool*/ ctx[0].sectors.length > 0 && create_if_block_1(ctx);
	let if_block5 = /*tool*/ ctx[0].languages && /*tool*/ ctx[0].languages.length > 0 && create_if_block(ctx);

	const block = {
		c: function create() {
			article = element("article");
			header = element("header");
			h2 = element("h2");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			div = element("div");
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (if_block5) if_block5.c();
			this.h();
		},
		l: function claim(nodes) {
			article = claim_element(nodes, "ARTICLE", { class: true, "data-niche": true });
			var article_nodes = children(article);
			header = claim_element(article_nodes, "HEADER", {});
			var header_nodes = children(header);
			h2 = claim_element(header_nodes, "H2", {});
			var h2_nodes = children(h2);
			a = claim_element(h2_nodes, "A", { class: true, href: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			h2_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			t1 = claim_space(article_nodes);
			div = claim_element(article_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			t4 = claim_space(div_nodes);
			if (if_block3) if_block3.l(div_nodes);
			t5 = claim_space(div_nodes);
			if (if_block4) if_block4.l(div_nodes);
			t6 = claim_space(div_nodes);
			if (if_block5) if_block5.l(div_nodes);
			div_nodes.forEach(detach_dev);
			article_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "class", "card__link");
			attr_dev(a, "href", a_href_value = "/tools/" + /*tool*/ ctx[0].slug + "/");
			add_location(a, file, 18, 12, 469);
			add_location(h2, file, 18, 8, 465);
			add_location(header, file, 17, 4, 448);
			attr_dev(div, "class", "meta");
			add_location(div, file, 20, 4, 559);
			attr_dev(article, "class", "card");

			attr_dev(article, "data-niche", article_data_niche_value = /*tool*/ ctx[0].niches
			? Object.keys(/*tool*/ ctx[0].niches).join(" ")
			: "");

			add_location(article, file, 16, 0, 354);
		},
		m: function mount(target, anchor) {
			insert_dev(target, article, anchor);
			append_dev(article, header);
			append_dev(header, h2);
			append_dev(h2, a);
			append_dev(a, t0);
			append_dev(article, t1);
			append_dev(article, div);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			append_dev(div, t4);
			if (if_block3) if_block3.m(div, null);
			append_dev(div, t5);
			if (if_block4) if_block4.m(div, null);
			append_dev(div, t6);
			if (if_block5) if_block5.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*tool*/ 1 && t0_value !== (t0_value = /*tool*/ ctx[0].name + "")) set_data_dev(t0, t0_value);

			if (dirty & /*tool*/ 1 && a_href_value !== (a_href_value = "/tools/" + /*tool*/ ctx[0].slug + "/")) {
				attr_dev(a, "href", a_href_value);
			}

			if (/*tool*/ ctx[0].niches) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					if_block0.m(div, t2);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*tool*/ ctx[0].useCount > 0) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					if_block1.m(div, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*tool*/ ctx[0].pricing) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_3(ctx);
					if_block2.c();
					if_block2.m(div, t4);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*tool*/ ctx[0].license) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_2(ctx);
					if_block3.c();
					if_block3.m(div, t5);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*tool*/ ctx[0].sectors && /*tool*/ ctx[0].sectors.length > 0) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_1(ctx);
					if_block4.c();
					if_block4.m(div, t6);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*tool*/ ctx[0].languages && /*tool*/ ctx[0].languages.length > 0) {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block(ctx);
					if_block5.c();
					if_block5.m(div, null);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (dirty & /*tool*/ 1 && article_data_niche_value !== (article_data_niche_value = /*tool*/ ctx[0].niches
			? Object.keys(/*tool*/ ctx[0].niches).join(" ")
			: "")) {
				attr_dev(article, "data-niche", article_data_niche_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(article);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function fancyConcat(array) {
	let output;

	if (array.length > 2) {
		const lastItem = array.pop();
		output = array.join(", ");
		output += `, and ${lastItem}`;
	} else {
		output = array.join(" and ");
	}

	return output;
}

const func = niche => niche.toLowerCase();

function instance($$self, $$props, $$invalidate) {
	let { tool } = $$props;
	const writable_props = ["tool"];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Card> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Card", $$slots, []);

	$$self.$set = $$props => {
		if ("tool" in $$props) $$invalidate(0, tool = $$props.tool);
	};

	$$self.$capture_state = () => ({ tool, fancyConcat });

	$$self.$inject_state = $$props => {
		if ("tool" in $$props) $$invalidate(0, tool = $$props.tool);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [tool];
}

class Card extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { tool: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Card",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*tool*/ ctx[0] === undefined && !("tool" in props)) {
			console.warn("<Card> was created without expected prop 'tool'");
		}
	}

	get tool() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tool(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var slugify = createCommonjsModule(function (module, exports) {
(function (name, root, factory) {
  {
    module.exports = factory();
    module.exports['default'] = factory();
  }
}('slugify', commonjsGlobal, function () {
  var charMap = JSON.parse('{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","¢":"cent","£":"pound","¤":"currency","¥":"yen","©":"(c)","ª":"a","®":"(r)","º":"o","À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","Æ":"AE","Ç":"C","È":"E","É":"E","Ê":"E","Ë":"E","Ì":"I","Í":"I","Î":"I","Ï":"I","Ð":"D","Ñ":"N","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","Ù":"U","Ú":"U","Û":"U","Ü":"U","Ý":"Y","Þ":"TH","ß":"ss","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","æ":"ae","ç":"c","è":"e","é":"e","ê":"e","ë":"e","ì":"i","í":"i","î":"i","ï":"i","ð":"d","ñ":"n","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","ù":"u","ú":"u","û":"u","ü":"u","ý":"y","þ":"th","ÿ":"y","Ā":"A","ā":"a","Ă":"A","ă":"a","Ą":"A","ą":"a","Ć":"C","ć":"c","Č":"C","č":"c","Ď":"D","ď":"d","Đ":"DJ","đ":"dj","Ē":"E","ē":"e","Ė":"E","ė":"e","Ę":"e","ę":"e","Ě":"E","ě":"e","Ğ":"G","ğ":"g","Ģ":"G","ģ":"g","Ĩ":"I","ĩ":"i","Ī":"i","ī":"i","Į":"I","į":"i","İ":"I","ı":"i","Ķ":"k","ķ":"k","Ļ":"L","ļ":"l","Ľ":"L","ľ":"l","Ł":"L","ł":"l","Ń":"N","ń":"n","Ņ":"N","ņ":"n","Ň":"N","ň":"n","Ő":"O","ő":"o","Œ":"OE","œ":"oe","Ŕ":"R","ŕ":"r","Ř":"R","ř":"r","Ś":"S","ś":"s","Ş":"S","ş":"s","Š":"S","š":"s","Ţ":"T","ţ":"t","Ť":"T","ť":"t","Ũ":"U","ũ":"u","Ū":"u","ū":"u","Ů":"U","ů":"u","Ű":"U","ű":"u","Ų":"U","ų":"u","Ŵ":"W","ŵ":"w","Ŷ":"Y","ŷ":"y","Ÿ":"Y","Ź":"Z","ź":"z","Ż":"Z","ż":"z","Ž":"Z","ž":"z","ƒ":"f","Ơ":"O","ơ":"o","Ư":"U","ư":"u","ǈ":"LJ","ǉ":"lj","ǋ":"NJ","ǌ":"nj","Ș":"S","ș":"s","Ț":"T","ț":"t","˚":"o","Ά":"A","Έ":"E","Ή":"H","Ί":"I","Ό":"O","Ύ":"Y","Ώ":"W","ΐ":"i","Α":"A","Β":"B","Γ":"G","Δ":"D","Ε":"E","Ζ":"Z","Η":"H","Θ":"8","Ι":"I","Κ":"K","Λ":"L","Μ":"M","Ν":"N","Ξ":"3","Ο":"O","Π":"P","Ρ":"R","Σ":"S","Τ":"T","Υ":"Y","Φ":"F","Χ":"X","Ψ":"PS","Ω":"W","Ϊ":"I","Ϋ":"Y","ά":"a","έ":"e","ή":"h","ί":"i","ΰ":"y","α":"a","β":"b","γ":"g","δ":"d","ε":"e","ζ":"z","η":"h","θ":"8","ι":"i","κ":"k","λ":"l","μ":"m","ν":"n","ξ":"3","ο":"o","π":"p","ρ":"r","ς":"s","σ":"s","τ":"t","υ":"y","φ":"f","χ":"x","ψ":"ps","ω":"w","ϊ":"i","ϋ":"y","ό":"o","ύ":"y","ώ":"w","Ё":"Yo","Ђ":"DJ","Є":"Ye","І":"I","Ї":"Yi","Ј":"J","Љ":"LJ","Њ":"NJ","Ћ":"C","Џ":"DZ","А":"A","Б":"B","В":"V","Г":"G","Д":"D","Е":"E","Ж":"Zh","З":"Z","И":"I","Й":"J","К":"K","Л":"L","М":"M","Н":"N","О":"O","П":"P","Р":"R","С":"S","Т":"T","У":"U","Ф":"F","Х":"H","Ц":"C","Ч":"Ch","Ш":"Sh","Щ":"Sh","Ъ":"U","Ы":"Y","Ь":"","Э":"E","Ю":"Yu","Я":"Ya","а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ж":"zh","з":"z","и":"i","й":"j","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"h","ц":"c","ч":"ch","ш":"sh","щ":"sh","ъ":"u","ы":"y","ь":"","э":"e","ю":"yu","я":"ya","ё":"yo","ђ":"dj","є":"ye","і":"i","ї":"yi","ј":"j","љ":"lj","њ":"nj","ћ":"c","ѝ":"u","џ":"dz","Ґ":"G","ґ":"g","Ғ":"GH","ғ":"gh","Қ":"KH","қ":"kh","Ң":"NG","ң":"ng","Ү":"UE","ү":"ue","Ұ":"U","ұ":"u","Һ":"H","һ":"h","Ә":"AE","ә":"ae","Ө":"OE","ө":"oe","฿":"baht","ა":"a","ბ":"b","გ":"g","დ":"d","ე":"e","ვ":"v","ზ":"z","თ":"t","ი":"i","კ":"k","ლ":"l","მ":"m","ნ":"n","ო":"o","პ":"p","ჟ":"zh","რ":"r","ს":"s","ტ":"t","უ":"u","ფ":"f","ქ":"k","ღ":"gh","ყ":"q","შ":"sh","ჩ":"ch","ც":"ts","ძ":"dz","წ":"ts","ჭ":"ch","ხ":"kh","ჯ":"j","ჰ":"h","Ẁ":"W","ẁ":"w","Ẃ":"W","ẃ":"w","Ẅ":"W","ẅ":"w","ẞ":"SS","Ạ":"A","ạ":"a","Ả":"A","ả":"a","Ấ":"A","ấ":"a","Ầ":"A","ầ":"a","Ẩ":"A","ẩ":"a","Ẫ":"A","ẫ":"a","Ậ":"A","ậ":"a","Ắ":"A","ắ":"a","Ằ":"A","ằ":"a","Ẳ":"A","ẳ":"a","Ẵ":"A","ẵ":"a","Ặ":"A","ặ":"a","Ẹ":"E","ẹ":"e","Ẻ":"E","ẻ":"e","Ẽ":"E","ẽ":"e","Ế":"E","ế":"e","Ề":"E","ề":"e","Ể":"E","ể":"e","Ễ":"E","ễ":"e","Ệ":"E","ệ":"e","Ỉ":"I","ỉ":"i","Ị":"I","ị":"i","Ọ":"O","ọ":"o","Ỏ":"O","ỏ":"o","Ố":"O","ố":"o","Ồ":"O","ồ":"o","Ổ":"O","ổ":"o","Ỗ":"O","ỗ":"o","Ộ":"O","ộ":"o","Ớ":"O","ớ":"o","Ờ":"O","ờ":"o","Ở":"O","ở":"o","Ỡ":"O","ỡ":"o","Ợ":"O","ợ":"o","Ụ":"U","ụ":"u","Ủ":"U","ủ":"u","Ứ":"U","ứ":"u","Ừ":"U","ừ":"u","Ử":"U","ử":"u","Ữ":"U","ữ":"u","Ự":"U","ự":"u","Ỳ":"Y","ỳ":"y","Ỵ":"Y","ỵ":"y","Ỷ":"Y","ỷ":"y","Ỹ":"Y","ỹ":"y","‘":"\'","’":"\'","“":"\\\"","”":"\\\"","†":"+","•":"*","…":"...","₠":"ecu","₢":"cruzeiro","₣":"french franc","₤":"lira","₥":"mill","₦":"naira","₧":"peseta","₨":"rupee","₩":"won","₪":"new shequel","₫":"dong","€":"euro","₭":"kip","₮":"tugrik","₯":"drachma","₰":"penny","₱":"peso","₲":"guarani","₳":"austral","₴":"hryvnia","₵":"cedi","₸":"kazakhstani tenge","₹":"indian rupee","₽":"russian ruble","₿":"bitcoin","℠":"sm","™":"tm","∂":"d","∆":"delta","∑":"sum","∞":"infinity","♥":"love","元":"yuan","円":"yen","﷼":"rial"}');
  var locales = JSON.parse('{"vi":{"Đ":"D","đ":"d"}}');

  function replace (string, options) {
    if (typeof string !== 'string') {
      throw new Error('slugify: string argument expected')
    }

    options = (typeof options === 'string')
      ? {replacement: options}
      : options || {};

    var locale = locales[options.locale] || {};

    var replacement = options.replacement || '-';

    var slug = string.split('')
      // replace characters based on charMap
      .reduce(function (result, ch) {
        return result + (locale[ch] || charMap[ch] || ch)
      }, '')
      // remove not allowed characters
      .replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, '')
      // trim leading/trailing spaces
      .trim()
      // convert spaces to replacement character
      // also remove duplicates of the replacement character
      .replace(new RegExp('[\\s' + replacement + ']+', 'g'), replacement);

    if (options.lower) {
      slug = slug.toLowerCase();
    }

    if (options.strict) {
      // remove anything besides letters, numbers, and the replacement char
      slug = slug
        .replace(new RegExp('[^a-zA-Z0-9' + replacement + ']', 'g'), '');
    }

    return slug
  }

  replace.extend = function (customMap) {
    for (var key in customMap) {
      charMap[key] = customMap[key];
    }
  };

  return replace
}));
});

/* src/components/RadioGroupButton.svelte generated by Svelte v3.22.2 */

const { Object: Object_1$1 } = globals;
const file$1 = "src/components/RadioGroupButton.svelte";

function create_fragment$1(ctx) {
	let button;
	let t;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text(/*label*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {
				id: true,
				role: true,
				type: true,
				"aria-checked": true,
				class: true
			});

			var button_nodes = children(button);
			t = claim_text(button_nodes, /*label*/ ctx[2]);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "id", /*id*/ ctx[0]);
			attr_dev(button, "role", "radio");
			attr_dev(button, "type", "button");
			attr_dev(button, "aria-checked", /*checked*/ ctx[1]);
			attr_dev(button, "class", "button button--radio svelte-1w8629v");
			add_location(button, file$1, 35, 0, 672);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
			if (remount) run_all(dispose);

			dispose = [
				listen_dev(button, "click", /*click_handler*/ ctx[7], false, false, false),
				listen_dev(button, "keydown", /*keydown_handler*/ ctx[8], false, false, false)
			];
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*label*/ 4) set_data_dev(t, /*label*/ ctx[2]);

			if (dirty & /*id*/ 1) {
				attr_dev(button, "id", /*id*/ ctx[0]);
			}

			if (dirty & /*checked*/ 2) {
				attr_dev(button, "aria-checked", /*checked*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();

	const keyCodes = Object.freeze({
		"LEFT": 37,
		"UP": 38,
		"RIGHT": 39,
		"DOWN": 40
	});

	let { id } = $$props;
	let { checked } = $$props;
	let { label } = $$props;

	function checkSelection(label) {
		dispatch("check", { label });
	}

	function handleKeyDown(event) {
		switch (event.keyCode) {
			case keyCodes.UP:
			case keyCodes.LEFT:
				dispatch("checkPrevious", { label });
				break;
			case keyCodes.DOWN:
			case keyCodes.RIGHT:
				dispatch("checkNext", { label });
				break;
		}
	}

	const writable_props = ["id", "checked", "label"];

	Object_1$1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RadioGroupButton> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("RadioGroupButton", $$slots, []);
	const click_handler = () => checkSelection(label);
	const keydown_handler = event => handleKeyDown(event);

	$$self.$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		dispatch,
		keyCodes,
		id,
		checked,
		label,
		checkSelection,
		handleKeyDown
	});

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		id,
		checked,
		label,
		checkSelection,
		handleKeyDown,
		dispatch,
		keyCodes,
		click_handler,
		keydown_handler
	];
}

class RadioGroupButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { id: 0, checked: 1, label: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RadioGroupButton",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[0] === undefined && !("id" in props)) {
			console.warn("<RadioGroupButton> was created without expected prop 'id'");
		}

		if (/*checked*/ ctx[1] === undefined && !("checked" in props)) {
			console.warn("<RadioGroupButton> was created without expected prop 'checked'");
		}

		if (/*label*/ ctx[2] === undefined && !("label" in props)) {
			console.warn("<RadioGroupButton> was created without expected prop 'label'");
		}
	}

	get id() {
		throw new Error("<RadioGroupButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<RadioGroupButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<RadioGroupButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<RadioGroupButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<RadioGroupButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<RadioGroupButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/RadioGroup.svelte generated by Svelte v3.22.2 */
const file$2 = "src/components/RadioGroup.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

// (31:1) {#each options as option}
function create_each_block$1(ctx) {
	let current;

	const radiogroupbutton = new RadioGroupButton({
			props: {
				id: slugify(/*option*/ ctx[8], { lower: true }),
				checked: /*activeOption*/ ctx[0] === /*option*/ ctx[8]
				? "true"
				: "false",
				label: /*option*/ ctx[8]
			},
			$$inline: true
		});

	radiogroupbutton.$on("check", /*check_handler*/ ctx[5]);
	radiogroupbutton.$on("checkPrevious", /*checkPrevious_handler*/ ctx[6]);
	radiogroupbutton.$on("checkNext", /*checkNext_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(radiogroupbutton.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(radiogroupbutton.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(radiogroupbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radiogroupbutton_changes = {};
			if (dirty & /*options*/ 2) radiogroupbutton_changes.id = slugify(/*option*/ ctx[8], { lower: true });

			if (dirty & /*activeOption, options*/ 3) radiogroupbutton_changes.checked = /*activeOption*/ ctx[0] === /*option*/ ctx[8]
			? "true"
			: "false";

			if (dirty & /*options*/ 2) radiogroupbutton_changes.label = /*option*/ ctx[8];
			radiogroupbutton.$set(radiogroupbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radiogroupbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radiogroupbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radiogroupbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(31:1) {#each options as option}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let current;
	let each_value = /*options*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "radio-group");
			add_location(div, file$2, 29, 0, 831);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*slugify, options, activeOption, handleCheck, handleCheckPrevious, handleCheckNext*/ 31) {
				each_value = /*options*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { options } = $$props;
	let { activeOption } = $$props;

	const handleCheck = value => {
		$$invalidate(0, activeOption = value);
	};

	const handleCheckPrevious = value => {
		const currentIndex = options.indexOf(value);

		const newIndex = currentIndex === 0
		? options.length - 1
		: currentIndex - 1;

		const newButton = document.getElementById(slugify(options[newIndex], { lower: true }));
		newButton.focus();
		$$invalidate(0, activeOption = options[newIndex]);
	};

	const handleCheckNext = value => {
		const currentIndex = options.indexOf(value);

		const newIndex = currentIndex === options.length - 1
		? 0
		: currentIndex + 1;

		const newButton = document.getElementById(slugify(options[newIndex], { lower: true }));
		newButton.focus();
		$$invalidate(0, activeOption = options[newIndex]);
	};

	const writable_props = ["options", "activeOption"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RadioGroup> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("RadioGroup", $$slots, []);
	const check_handler = event => handleCheck(event.detail.label);
	const checkPrevious_handler = event => handleCheckPrevious(event.detail.label);
	const checkNext_handler = event => handleCheckNext(event.detail.label);

	$$self.$set = $$props => {
		if ("options" in $$props) $$invalidate(1, options = $$props.options);
		if ("activeOption" in $$props) $$invalidate(0, activeOption = $$props.activeOption);
	};

	$$self.$capture_state = () => ({
		slugify,
		options,
		activeOption,
		handleCheck,
		handleCheckPrevious,
		handleCheckNext,
		RadioGroupButton
	});

	$$self.$inject_state = $$props => {
		if ("options" in $$props) $$invalidate(1, options = $$props.options);
		if ("activeOption" in $$props) $$invalidate(0, activeOption = $$props.activeOption);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		activeOption,
		options,
		handleCheck,
		handleCheckPrevious,
		handleCheckNext,
		check_handler,
		checkPrevious_handler,
		checkNext_handler
	];
}

class RadioGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { options: 1, activeOption: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RadioGroup",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*options*/ ctx[1] === undefined && !("options" in props)) {
			console.warn("<RadioGroup> was created without expected prop 'options'");
		}

		if (/*activeOption*/ ctx[0] === undefined && !("activeOption" in props)) {
			console.warn("<RadioGroup> was created without expected prop 'activeOption'");
		}
	}

	get options() {
		throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set options(value) {
		throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeOption() {
		throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeOption(value) {
		throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/index.svelte generated by Svelte v3.22.2 */
const file$3 = "src/routes/index.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (56:2) {#each tools as tool}
function create_each_block$2(ctx) {
	let current;

	const card = new Card({
			props: { tool: /*tool*/ ctx[2] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const card_changes = {};
			if (dirty & /*tools*/ 1) card_changes.tool = /*tool*/ ctx[2];
			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(56:2) {#each tools as tool}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let t0;
	let div2;
	let div1;
	let h1;
	let t1;
	let t2;
	let p;
	let t3;
	let t4;
	let div0;
	let ul;
	let li0;
	let a0;
	let t5;
	let br0;
	let t6;
	let t7;
	let li1;
	let a1;
	let t8;
	let br1;
	let t9;
	let t10;
	let li2;
	let a2;
	let t11;
	let br2;
	let t12;
	let t13;
	let div5;
	let div3;
	let h3;
	let t14;
	let t15;
	let t16;
	let div4;
	let current;

	const radiogroup = new RadioGroup({
			props: {
				options: /*niches*/ ctx[1],
				activeOption: "All"
			},
			$$inline: true
		});

	let each_value = /*tools*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			t0 = space();
			div2 = element("div");
			div1 = element("div");
			h1 = element("h1");
			t1 = text("Cooperative Tool Library");
			t2 = space();
			p = element("p");
			t3 = text("Practical tools for co-ops.");
			t4 = space();
			div0 = element("div");
			ul = element("ul");
			li0 = element("li");
			a0 = element("a");
			t5 = text("Find practical tools");
			br0 = element("br");
			t6 = text("\n\t\t\t\t\tfor your co-op");
			t7 = space();
			li1 = element("li");
			a1 = element("a");
			t8 = text("See other co-op’s tools");
			br1 = element("br");
			t9 = text("\n\t\t\t\t\tSee other co-op’s tools");
			t10 = space();
			li2 = element("li");
			a2 = element("a");
			t11 = text("Share your tools");
			br2 = element("br");
			t12 = text("\n\t\t\t\t\tto help other co-ops find tools");
			t13 = space();
			div5 = element("div");
			div3 = element("div");
			h3 = element("h3");
			t14 = text("Find tools");
			t15 = space();
			create_component(radiogroup.$$.fragment);
			t16 = space();
			div4 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1k640h7\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			h1 = claim_element(div1_nodes, "H1", {});
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, "Cooperative Tool Library");
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(div1_nodes);
			p = claim_element(div1_nodes, "P", { class: true });
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, "Practical tools for co-ops.");
			p_nodes.forEach(detach_dev);
			t4 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			ul = claim_element(div0_nodes, "UL", {});
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", {});
			var li0_nodes = children(li0);
			a0 = claim_element(li0_nodes, "A", { href: true });
			var a0_nodes = children(a0);
			t5 = claim_text(a0_nodes, "Find practical tools");
			a0_nodes.forEach(detach_dev);
			br0 = claim_element(li0_nodes, "BR", {});
			t6 = claim_text(li0_nodes, "\n\t\t\t\t\tfor your co-op");
			li0_nodes.forEach(detach_dev);
			t7 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", {});
			var li1_nodes = children(li1);
			a1 = claim_element(li1_nodes, "A", { href: true });
			var a1_nodes = children(a1);
			t8 = claim_text(a1_nodes, "See other co-op’s tools");
			a1_nodes.forEach(detach_dev);
			br1 = claim_element(li1_nodes, "BR", {});
			t9 = claim_text(li1_nodes, "\n\t\t\t\t\tSee other co-op’s tools");
			li1_nodes.forEach(detach_dev);
			t10 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", {});
			var li2_nodes = children(li2);
			a2 = claim_element(li2_nodes, "A", { href: true });
			var a2_nodes = children(a2);
			t11 = claim_text(a2_nodes, "Share your tools");
			a2_nodes.forEach(detach_dev);
			br2 = claim_element(li2_nodes, "BR", {});
			t12 = claim_text(li2_nodes, "\n\t\t\t\t\tto help other co-ops find tools");
			li2_nodes.forEach(detach_dev);
			ul_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			div5 = claim_element(nodes, "DIV", { id: true });
			var div5_nodes = children(div5);
			div3 = claim_element(div5_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			h3 = claim_element(div3_nodes, "H3", {});
			var h3_nodes = children(h3);
			t14 = claim_text(h3_nodes, "Find tools");
			h3_nodes.forEach(detach_dev);
			t15 = claim_space(div3_nodes);
			claim_component(radiogroup.$$.fragment, div3_nodes);
			div3_nodes.forEach(detach_dev);
			t16 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div4_nodes);
			}

			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Co-op Tool Library";
			add_location(h1, file$3, 29, 2, 566);
			attr_dev(p, "class", "subhead");
			add_location(p, file$3, 30, 2, 602);
			attr_dev(a0, "href", "#tools");
			add_location(a0, file$3, 34, 5, 707);
			add_location(br0, file$3, 34, 46, 748);
			add_location(li0, file$3, 33, 4, 697);
			attr_dev(a1, "href", "/get-recommendations/");
			add_location(a1, file$3, 38, 5, 797);
			add_location(br1, file$3, 38, 64, 856);
			add_location(li1, file$3, 37, 4, 787);
			attr_dev(a2, "href", "/share-tools/");
			add_location(a2, file$3, 42, 5, 914);
			add_location(br2, file$3, 42, 49, 958);
			add_location(li2, file$3, 41, 4, 904);
			add_location(ul, file$3, 32, 3, 688);
			attr_dev(div0, "class", "calls-to-action");
			add_location(div0, file$3, 31, 2, 655);
			attr_dev(div1, "class", "inside");
			add_location(div1, file$3, 28, 1, 543);
			attr_dev(div2, "class", "page-header");
			add_location(div2, file$3, 27, 0, 516);
			add_location(h3, file$3, 51, 2, 1084);
			attr_dev(div3, "class", "niches");
			add_location(div3, file$3, 50, 1, 1061);
			attr_dev(div4, "class", "cards");
			add_location(div4, file$3, 54, 1, 1168);
			attr_dev(div5, "id", "tools");
			add_location(div5, file$3, 49, 0, 1043);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, h1);
			append_dev(h1, t1);
			append_dev(div1, t2);
			append_dev(div1, p);
			append_dev(p, t3);
			append_dev(div1, t4);
			append_dev(div1, div0);
			append_dev(div0, ul);
			append_dev(ul, li0);
			append_dev(li0, a0);
			append_dev(a0, t5);
			append_dev(li0, br0);
			append_dev(li0, t6);
			append_dev(ul, t7);
			append_dev(ul, li1);
			append_dev(li1, a1);
			append_dev(a1, t8);
			append_dev(li1, br1);
			append_dev(li1, t9);
			append_dev(ul, t10);
			append_dev(ul, li2);
			append_dev(li2, a2);
			append_dev(a2, t11);
			append_dev(li2, br2);
			append_dev(li2, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, div5, anchor);
			append_dev(div5, div3);
			append_dev(div3, h3);
			append_dev(h3, t14);
			append_dev(div3, t15);
			mount_component(radiogroup, div3, null);
			append_dev(div5, t16);
			append_dev(div5, div4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div4, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			const radiogroup_changes = {};
			if (dirty & /*niches*/ 2) radiogroup_changes.options = /*niches*/ ctx[1];
			radiogroup.$set(radiogroup_changes);

			if (dirty & /*tools*/ 1) {
				each_value = /*tools*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div4, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radiogroup.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(radiogroup.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div2);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(div5);
			destroy_component(radiogroup);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload({ params, query }) {
	let tools = await this.fetch(`tools.json`);
	tools = await tools.json();
	let niches = await this.fetch(`niches.json`);
	niches = await niches.json();
	return { tools, niches };
}

function instance$3($$self, $$props, $$invalidate) {
	let { tools } = $$props;
	let { niches } = $$props;
	const writable_props = ["tools", "niches"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Routes> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Routes", $$slots, []);

	$$self.$set = $$props => {
		if ("tools" in $$props) $$invalidate(0, tools = $$props.tools);
		if ("niches" in $$props) $$invalidate(1, niches = $$props.niches);
	};

	$$self.$capture_state = () => ({ preload, tools, niches, Card, RadioGroup });

	$$self.$inject_state = $$props => {
		if ("tools" in $$props) $$invalidate(0, tools = $$props.tools);
		if ("niches" in $$props) $$invalidate(1, niches = $$props.niches);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [tools, niches];
}

class Routes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { tools: 0, niches: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routes",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*tools*/ ctx[0] === undefined && !("tools" in props)) {
			console.warn("<Routes> was created without expected prop 'tools'");
		}

		if (/*niches*/ ctx[1] === undefined && !("niches" in props)) {
			console.warn("<Routes> was created without expected prop 'niches'");
		}
	}

	get tools() {
		throw new Error("<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tools(value) {
		throw new Error("<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get niches() {
		throw new Error("<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set niches(value) {
		throw new Error("<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Routes;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNzU4ODM5NWIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0NhcmQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NsdWdpZnkvc2x1Z2lmeS5qcyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1JhZGlvR3JvdXBCdXR0b24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvUmFkaW9Hcm91cC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2luZGV4LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGV4cG9ydCBsZXQgdG9vbDtcbiAgICBcbiAgICBmdW5jdGlvbiBmYW5jeUNvbmNhdChhcnJheSkge1xuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgY29uc3QgbGFzdEl0ZW0gPSBhcnJheS5wb3AoKTtcbiAgICAgICAgICAgIG91dHB1dCA9IGFycmF5LmpvaW4oJywgJyk7XG4gICAgICAgICAgICBvdXRwdXQgKz0gYCwgYW5kICR7bGFzdEl0ZW19YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGFycmF5LmpvaW4oJyBhbmQgJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbjwvc2NyaXB0PlxuPGFydGljbGUgY2xhc3M9XCJjYXJkXCIgZGF0YS1uaWNoZT17dG9vbC5uaWNoZXMgPyBPYmplY3Qua2V5cyh0b29sLm5pY2hlcykuam9pbignICcpIDogJyd9PlxuICAgIDxoZWFkZXI+XG4gICAgICAgIDxoMj48YSBjbGFzcz1cImNhcmRfX2xpbmtcIiBocmVmPVwiL3Rvb2xzL3t0b29sLnNsdWd9L1wiPnsgdG9vbC5uYW1lIH08L2E+PC9oMj5cbiAgICA8L2hlYWRlcj5cbiAgICA8ZGl2IGNsYXNzPVwibWV0YVwiPlxuICAgICAgICB7I2lmIHRvb2wubmljaGVzIH1cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRfX21ldGFcIj48c3BhbiBjbGFzcz1cInNjcmVlbi1yZWFkZXItdGV4dFwiPnRvb2wgdHlwZTogPC9zcGFuPlxuICAgICAgICB7I2VhY2ggT2JqZWN0LmtleXModG9vbC5uaWNoZXMpIGFzIG5pY2hlfVxuICAgICAgICAgICAgeyBuaWNoZSB9eyNpZiB0b29sLm5pY2hlc1tuaWNoZV0ubGVuZ3RoID4gMH06IHsgdG9vbC5uaWNoZXNbbmljaGVdLm1hcChuaWNoZSA9PiBuaWNoZS50b0xvd2VyQ2FzZSgpKS5qb2luKCcsICcpIH17L2lmfTxiciAvPlxuICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgICAgICB7I2lmIHRvb2wudXNlQ291bnQgPiAwfVxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZF9fbWV0YVwiPnsgdG9vbC51c2Vjb3VudCB9IHsgdG9vbC51c2Vjb3VudCA+IDEgPyAnY29vcHMgdXNlJyA6ICdjb29wIHVzZXMnIH0gaXQ8L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICAgICAgeyNpZiB0b29sLnByaWNpbmcgfVxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZF9fbWV0YVwiPjxzdmcgY2xhc3M9XCJpY29uIGljb24tLXJlcG9ydFwiIHZpZXdCb3g9XCIwIDAgMjAgMjBcIiBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiPjx1c2UgaHJlZj1cIi9pbWFnZXMvcmVwb3J0LnN2ZyNyZXBvcnRcIiAvPjwvc3ZnPiBQcmljaW5nOiB7IHRvb2wucHJpY2luZyB9PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgdG9vbC5saWNlbnNlIH1cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRfX21ldGFcIj48c3ZnIGNsYXNzPVwiaWNvbiBpY29uLS1zZXR0aW5nc1wiIHZpZXdCb3g9XCIwIDAgMjAgMjBcIiBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiPjx1c2UgaHJlZj1cIi9pbWFnZXMvc2V0dGluZ3Muc3ZnI3NldHRpbmdzXCIgLz48L3N2Zz4gTGljZW5zaW5nOiB7IHRvb2wubGljZW5zZSB9PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgdG9vbC5zZWN0b3JzICYmIHRvb2wuc2VjdG9ycy5sZW5ndGggPiAwIH1cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRfX21ldGFcIj48c3ZnIGNsYXNzPVwiaWNvbiBpY29uLS1zZWN0b3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIj48dXNlIGhyZWY9XCIvaW1hZ2VzL3NlY3Rvci5zdmcjc2VjdG9yXCIgLz48L3N2Zz4gU2VjdG9yOiB7IGZhbmN5Q29uY2F0KHRvb2wuc2VjdG9ycykgfTwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgICAgICB7I2lmIHRvb2wubGFuZ3VhZ2VzICYmIHRvb2wubGFuZ3VhZ2VzLmxlbmd0aCA+IDAgfVxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZF9fbWV0YVwiPjxzdmcgY2xhc3M9XCJpY29uIGljb24tLWluZm9cIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIj48dXNlIGhyZWY9XCIvaW1hZ2VzL2luZm8uc3ZnI2luZm9cIiAvPjwvc3ZnPiBMYW5ndWFnZTogeyBmYW5jeUNvbmNhdCh0b29sLmxhbmd1YWdlcykgfTwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2PlxuPC9hcnRpY2xlPlxuIiwiXG47KGZ1bmN0aW9uIChuYW1lLCByb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICAgIG1vZHVsZS5leHBvcnRzWydkZWZhdWx0J10gPSBmYWN0b3J5KClcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZmFjdG9yeSlcbiAgfVxuICBlbHNlIHtcbiAgICByb290W25hbWVdID0gZmFjdG9yeSgpXG4gIH1cbn0oJ3NsdWdpZnknLCB0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaGFyTWFwID0gSlNPTi5wYXJzZSgne1wiJFwiOlwiZG9sbGFyXCIsXCIlXCI6XCJwZXJjZW50XCIsXCImXCI6XCJhbmRcIixcIjxcIjpcImxlc3NcIixcIj5cIjpcImdyZWF0ZXJcIixcInxcIjpcIm9yXCIsXCLColwiOlwiY2VudFwiLFwiwqNcIjpcInBvdW5kXCIsXCLCpFwiOlwiY3VycmVuY3lcIixcIsKlXCI6XCJ5ZW5cIixcIsKpXCI6XCIoYylcIixcIsKqXCI6XCJhXCIsXCLCrlwiOlwiKHIpXCIsXCLCulwiOlwib1wiLFwiw4BcIjpcIkFcIixcIsOBXCI6XCJBXCIsXCLDglwiOlwiQVwiLFwiw4NcIjpcIkFcIixcIsOEXCI6XCJBXCIsXCLDhVwiOlwiQVwiLFwiw4ZcIjpcIkFFXCIsXCLDh1wiOlwiQ1wiLFwiw4hcIjpcIkVcIixcIsOJXCI6XCJFXCIsXCLDilwiOlwiRVwiLFwiw4tcIjpcIkVcIixcIsOMXCI6XCJJXCIsXCLDjVwiOlwiSVwiLFwiw45cIjpcIklcIixcIsOPXCI6XCJJXCIsXCLDkFwiOlwiRFwiLFwiw5FcIjpcIk5cIixcIsOSXCI6XCJPXCIsXCLDk1wiOlwiT1wiLFwiw5RcIjpcIk9cIixcIsOVXCI6XCJPXCIsXCLDllwiOlwiT1wiLFwiw5hcIjpcIk9cIixcIsOZXCI6XCJVXCIsXCLDmlwiOlwiVVwiLFwiw5tcIjpcIlVcIixcIsOcXCI6XCJVXCIsXCLDnVwiOlwiWVwiLFwiw55cIjpcIlRIXCIsXCLDn1wiOlwic3NcIixcIsOgXCI6XCJhXCIsXCLDoVwiOlwiYVwiLFwiw6JcIjpcImFcIixcIsOjXCI6XCJhXCIsXCLDpFwiOlwiYVwiLFwiw6VcIjpcImFcIixcIsOmXCI6XCJhZVwiLFwiw6dcIjpcImNcIixcIsOoXCI6XCJlXCIsXCLDqVwiOlwiZVwiLFwiw6pcIjpcImVcIixcIsOrXCI6XCJlXCIsXCLDrFwiOlwiaVwiLFwiw61cIjpcImlcIixcIsOuXCI6XCJpXCIsXCLDr1wiOlwiaVwiLFwiw7BcIjpcImRcIixcIsOxXCI6XCJuXCIsXCLDslwiOlwib1wiLFwiw7NcIjpcIm9cIixcIsO0XCI6XCJvXCIsXCLDtVwiOlwib1wiLFwiw7ZcIjpcIm9cIixcIsO4XCI6XCJvXCIsXCLDuVwiOlwidVwiLFwiw7pcIjpcInVcIixcIsO7XCI6XCJ1XCIsXCLDvFwiOlwidVwiLFwiw71cIjpcInlcIixcIsO+XCI6XCJ0aFwiLFwiw79cIjpcInlcIixcIsSAXCI6XCJBXCIsXCLEgVwiOlwiYVwiLFwixIJcIjpcIkFcIixcIsSDXCI6XCJhXCIsXCLEhFwiOlwiQVwiLFwixIVcIjpcImFcIixcIsSGXCI6XCJDXCIsXCLEh1wiOlwiY1wiLFwixIxcIjpcIkNcIixcIsSNXCI6XCJjXCIsXCLEjlwiOlwiRFwiLFwixI9cIjpcImRcIixcIsSQXCI6XCJESlwiLFwixJFcIjpcImRqXCIsXCLEklwiOlwiRVwiLFwixJNcIjpcImVcIixcIsSWXCI6XCJFXCIsXCLEl1wiOlwiZVwiLFwixJhcIjpcImVcIixcIsSZXCI6XCJlXCIsXCLEmlwiOlwiRVwiLFwixJtcIjpcImVcIixcIsSeXCI6XCJHXCIsXCLEn1wiOlwiZ1wiLFwixKJcIjpcIkdcIixcIsSjXCI6XCJnXCIsXCLEqFwiOlwiSVwiLFwixKlcIjpcImlcIixcIsSqXCI6XCJpXCIsXCLEq1wiOlwiaVwiLFwixK5cIjpcIklcIixcIsSvXCI6XCJpXCIsXCLEsFwiOlwiSVwiLFwixLFcIjpcImlcIixcIsS2XCI6XCJrXCIsXCLEt1wiOlwia1wiLFwixLtcIjpcIkxcIixcIsS8XCI6XCJsXCIsXCLEvVwiOlwiTFwiLFwixL5cIjpcImxcIixcIsWBXCI6XCJMXCIsXCLFglwiOlwibFwiLFwixYNcIjpcIk5cIixcIsWEXCI6XCJuXCIsXCLFhVwiOlwiTlwiLFwixYZcIjpcIm5cIixcIsWHXCI6XCJOXCIsXCLFiFwiOlwiblwiLFwixZBcIjpcIk9cIixcIsWRXCI6XCJvXCIsXCLFklwiOlwiT0VcIixcIsWTXCI6XCJvZVwiLFwixZRcIjpcIlJcIixcIsWVXCI6XCJyXCIsXCLFmFwiOlwiUlwiLFwixZlcIjpcInJcIixcIsWaXCI6XCJTXCIsXCLFm1wiOlwic1wiLFwixZ5cIjpcIlNcIixcIsWfXCI6XCJzXCIsXCLFoFwiOlwiU1wiLFwixaFcIjpcInNcIixcIsWiXCI6XCJUXCIsXCLFo1wiOlwidFwiLFwixaRcIjpcIlRcIixcIsWlXCI6XCJ0XCIsXCLFqFwiOlwiVVwiLFwixalcIjpcInVcIixcIsWqXCI6XCJ1XCIsXCLFq1wiOlwidVwiLFwixa5cIjpcIlVcIixcIsWvXCI6XCJ1XCIsXCLFsFwiOlwiVVwiLFwixbFcIjpcInVcIixcIsWyXCI6XCJVXCIsXCLFs1wiOlwidVwiLFwixbRcIjpcIldcIixcIsW1XCI6XCJ3XCIsXCLFtlwiOlwiWVwiLFwixbdcIjpcInlcIixcIsW4XCI6XCJZXCIsXCLFuVwiOlwiWlwiLFwixbpcIjpcInpcIixcIsW7XCI6XCJaXCIsXCLFvFwiOlwielwiLFwixb1cIjpcIlpcIixcIsW+XCI6XCJ6XCIsXCLGklwiOlwiZlwiLFwixqBcIjpcIk9cIixcIsahXCI6XCJvXCIsXCLGr1wiOlwiVVwiLFwixrBcIjpcInVcIixcIseIXCI6XCJMSlwiLFwix4lcIjpcImxqXCIsXCLHi1wiOlwiTkpcIixcIseMXCI6XCJualwiLFwiyJhcIjpcIlNcIixcIsiZXCI6XCJzXCIsXCLImlwiOlwiVFwiLFwiyJtcIjpcInRcIixcIsuaXCI6XCJvXCIsXCLOhlwiOlwiQVwiLFwizohcIjpcIkVcIixcIs6JXCI6XCJIXCIsXCLOilwiOlwiSVwiLFwizoxcIjpcIk9cIixcIs6OXCI6XCJZXCIsXCLOj1wiOlwiV1wiLFwizpBcIjpcImlcIixcIs6RXCI6XCJBXCIsXCLOklwiOlwiQlwiLFwizpNcIjpcIkdcIixcIs6UXCI6XCJEXCIsXCLOlVwiOlwiRVwiLFwizpZcIjpcIlpcIixcIs6XXCI6XCJIXCIsXCLOmFwiOlwiOFwiLFwizplcIjpcIklcIixcIs6aXCI6XCJLXCIsXCLOm1wiOlwiTFwiLFwizpxcIjpcIk1cIixcIs6dXCI6XCJOXCIsXCLOnlwiOlwiM1wiLFwizp9cIjpcIk9cIixcIs6gXCI6XCJQXCIsXCLOoVwiOlwiUlwiLFwizqNcIjpcIlNcIixcIs6kXCI6XCJUXCIsXCLOpVwiOlwiWVwiLFwizqZcIjpcIkZcIixcIs6nXCI6XCJYXCIsXCLOqFwiOlwiUFNcIixcIs6pXCI6XCJXXCIsXCLOqlwiOlwiSVwiLFwizqtcIjpcIllcIixcIs6sXCI6XCJhXCIsXCLOrVwiOlwiZVwiLFwizq5cIjpcImhcIixcIs6vXCI6XCJpXCIsXCLOsFwiOlwieVwiLFwizrFcIjpcImFcIixcIs6yXCI6XCJiXCIsXCLOs1wiOlwiZ1wiLFwizrRcIjpcImRcIixcIs61XCI6XCJlXCIsXCLOtlwiOlwielwiLFwizrdcIjpcImhcIixcIs64XCI6XCI4XCIsXCLOuVwiOlwiaVwiLFwizrpcIjpcImtcIixcIs67XCI6XCJsXCIsXCLOvFwiOlwibVwiLFwizr1cIjpcIm5cIixcIs6+XCI6XCIzXCIsXCLOv1wiOlwib1wiLFwiz4BcIjpcInBcIixcIs+BXCI6XCJyXCIsXCLPglwiOlwic1wiLFwiz4NcIjpcInNcIixcIs+EXCI6XCJ0XCIsXCLPhVwiOlwieVwiLFwiz4ZcIjpcImZcIixcIs+HXCI6XCJ4XCIsXCLPiFwiOlwicHNcIixcIs+JXCI6XCJ3XCIsXCLPilwiOlwiaVwiLFwiz4tcIjpcInlcIixcIs+MXCI6XCJvXCIsXCLPjVwiOlwieVwiLFwiz45cIjpcIndcIixcItCBXCI6XCJZb1wiLFwi0IJcIjpcIkRKXCIsXCLQhFwiOlwiWWVcIixcItCGXCI6XCJJXCIsXCLQh1wiOlwiWWlcIixcItCIXCI6XCJKXCIsXCLQiVwiOlwiTEpcIixcItCKXCI6XCJOSlwiLFwi0ItcIjpcIkNcIixcItCPXCI6XCJEWlwiLFwi0JBcIjpcIkFcIixcItCRXCI6XCJCXCIsXCLQklwiOlwiVlwiLFwi0JNcIjpcIkdcIixcItCUXCI6XCJEXCIsXCLQlVwiOlwiRVwiLFwi0JZcIjpcIlpoXCIsXCLQl1wiOlwiWlwiLFwi0JhcIjpcIklcIixcItCZXCI6XCJKXCIsXCLQmlwiOlwiS1wiLFwi0JtcIjpcIkxcIixcItCcXCI6XCJNXCIsXCLQnVwiOlwiTlwiLFwi0J5cIjpcIk9cIixcItCfXCI6XCJQXCIsXCLQoFwiOlwiUlwiLFwi0KFcIjpcIlNcIixcItCiXCI6XCJUXCIsXCLQo1wiOlwiVVwiLFwi0KRcIjpcIkZcIixcItClXCI6XCJIXCIsXCLQplwiOlwiQ1wiLFwi0KdcIjpcIkNoXCIsXCLQqFwiOlwiU2hcIixcItCpXCI6XCJTaFwiLFwi0KpcIjpcIlVcIixcItCrXCI6XCJZXCIsXCLQrFwiOlwiXCIsXCLQrVwiOlwiRVwiLFwi0K5cIjpcIll1XCIsXCLQr1wiOlwiWWFcIixcItCwXCI6XCJhXCIsXCLQsVwiOlwiYlwiLFwi0LJcIjpcInZcIixcItCzXCI6XCJnXCIsXCLQtFwiOlwiZFwiLFwi0LVcIjpcImVcIixcItC2XCI6XCJ6aFwiLFwi0LdcIjpcInpcIixcItC4XCI6XCJpXCIsXCLQuVwiOlwialwiLFwi0LpcIjpcImtcIixcItC7XCI6XCJsXCIsXCLQvFwiOlwibVwiLFwi0L1cIjpcIm5cIixcItC+XCI6XCJvXCIsXCLQv1wiOlwicFwiLFwi0YBcIjpcInJcIixcItGBXCI6XCJzXCIsXCLRglwiOlwidFwiLFwi0YNcIjpcInVcIixcItGEXCI6XCJmXCIsXCLRhVwiOlwiaFwiLFwi0YZcIjpcImNcIixcItGHXCI6XCJjaFwiLFwi0YhcIjpcInNoXCIsXCLRiVwiOlwic2hcIixcItGKXCI6XCJ1XCIsXCLRi1wiOlwieVwiLFwi0YxcIjpcIlwiLFwi0Y1cIjpcImVcIixcItGOXCI6XCJ5dVwiLFwi0Y9cIjpcInlhXCIsXCLRkVwiOlwieW9cIixcItGSXCI6XCJkalwiLFwi0ZRcIjpcInllXCIsXCLRllwiOlwiaVwiLFwi0ZdcIjpcInlpXCIsXCLRmFwiOlwialwiLFwi0ZlcIjpcImxqXCIsXCLRmlwiOlwibmpcIixcItGbXCI6XCJjXCIsXCLRnVwiOlwidVwiLFwi0Z9cIjpcImR6XCIsXCLSkFwiOlwiR1wiLFwi0pFcIjpcImdcIixcItKSXCI6XCJHSFwiLFwi0pNcIjpcImdoXCIsXCLSmlwiOlwiS0hcIixcItKbXCI6XCJraFwiLFwi0qJcIjpcIk5HXCIsXCLSo1wiOlwibmdcIixcItKuXCI6XCJVRVwiLFwi0q9cIjpcInVlXCIsXCLSsFwiOlwiVVwiLFwi0rFcIjpcInVcIixcItK6XCI6XCJIXCIsXCLSu1wiOlwiaFwiLFwi05hcIjpcIkFFXCIsXCLTmVwiOlwiYWVcIixcItOoXCI6XCJPRVwiLFwi06lcIjpcIm9lXCIsXCLguL9cIjpcImJhaHRcIixcIuGDkFwiOlwiYVwiLFwi4YORXCI6XCJiXCIsXCLhg5JcIjpcImdcIixcIuGDk1wiOlwiZFwiLFwi4YOUXCI6XCJlXCIsXCLhg5VcIjpcInZcIixcIuGDllwiOlwielwiLFwi4YOXXCI6XCJ0XCIsXCLhg5hcIjpcImlcIixcIuGDmVwiOlwia1wiLFwi4YOaXCI6XCJsXCIsXCLhg5tcIjpcIm1cIixcIuGDnFwiOlwiblwiLFwi4YOdXCI6XCJvXCIsXCLhg55cIjpcInBcIixcIuGDn1wiOlwiemhcIixcIuGDoFwiOlwiclwiLFwi4YOhXCI6XCJzXCIsXCLhg6JcIjpcInRcIixcIuGDo1wiOlwidVwiLFwi4YOkXCI6XCJmXCIsXCLhg6VcIjpcImtcIixcIuGDplwiOlwiZ2hcIixcIuGDp1wiOlwicVwiLFwi4YOoXCI6XCJzaFwiLFwi4YOpXCI6XCJjaFwiLFwi4YOqXCI6XCJ0c1wiLFwi4YOrXCI6XCJkelwiLFwi4YOsXCI6XCJ0c1wiLFwi4YOtXCI6XCJjaFwiLFwi4YOuXCI6XCJraFwiLFwi4YOvXCI6XCJqXCIsXCLhg7BcIjpcImhcIixcIuG6gFwiOlwiV1wiLFwi4bqBXCI6XCJ3XCIsXCLhuoJcIjpcIldcIixcIuG6g1wiOlwid1wiLFwi4bqEXCI6XCJXXCIsXCLhuoVcIjpcIndcIixcIuG6nlwiOlwiU1NcIixcIuG6oFwiOlwiQVwiLFwi4bqhXCI6XCJhXCIsXCLhuqJcIjpcIkFcIixcIuG6o1wiOlwiYVwiLFwi4bqkXCI6XCJBXCIsXCLhuqVcIjpcImFcIixcIuG6plwiOlwiQVwiLFwi4bqnXCI6XCJhXCIsXCLhuqhcIjpcIkFcIixcIuG6qVwiOlwiYVwiLFwi4bqqXCI6XCJBXCIsXCLhuqtcIjpcImFcIixcIuG6rFwiOlwiQVwiLFwi4bqtXCI6XCJhXCIsXCLhuq5cIjpcIkFcIixcIuG6r1wiOlwiYVwiLFwi4bqwXCI6XCJBXCIsXCLhurFcIjpcImFcIixcIuG6slwiOlwiQVwiLFwi4bqzXCI6XCJhXCIsXCLhurRcIjpcIkFcIixcIuG6tVwiOlwiYVwiLFwi4bq2XCI6XCJBXCIsXCLhurdcIjpcImFcIixcIuG6uFwiOlwiRVwiLFwi4bq5XCI6XCJlXCIsXCLhurpcIjpcIkVcIixcIuG6u1wiOlwiZVwiLFwi4bq8XCI6XCJFXCIsXCLhur1cIjpcImVcIixcIuG6vlwiOlwiRVwiLFwi4bq/XCI6XCJlXCIsXCLhu4BcIjpcIkVcIixcIuG7gVwiOlwiZVwiLFwi4buCXCI6XCJFXCIsXCLhu4NcIjpcImVcIixcIuG7hFwiOlwiRVwiLFwi4buFXCI6XCJlXCIsXCLhu4ZcIjpcIkVcIixcIuG7h1wiOlwiZVwiLFwi4buIXCI6XCJJXCIsXCLhu4lcIjpcImlcIixcIuG7ilwiOlwiSVwiLFwi4buLXCI6XCJpXCIsXCLhu4xcIjpcIk9cIixcIuG7jVwiOlwib1wiLFwi4buOXCI6XCJPXCIsXCLhu49cIjpcIm9cIixcIuG7kFwiOlwiT1wiLFwi4buRXCI6XCJvXCIsXCLhu5JcIjpcIk9cIixcIuG7k1wiOlwib1wiLFwi4buUXCI6XCJPXCIsXCLhu5VcIjpcIm9cIixcIuG7llwiOlwiT1wiLFwi4buXXCI6XCJvXCIsXCLhu5hcIjpcIk9cIixcIuG7mVwiOlwib1wiLFwi4buaXCI6XCJPXCIsXCLhu5tcIjpcIm9cIixcIuG7nFwiOlwiT1wiLFwi4budXCI6XCJvXCIsXCLhu55cIjpcIk9cIixcIuG7n1wiOlwib1wiLFwi4bugXCI6XCJPXCIsXCLhu6FcIjpcIm9cIixcIuG7olwiOlwiT1wiLFwi4bujXCI6XCJvXCIsXCLhu6RcIjpcIlVcIixcIuG7pVwiOlwidVwiLFwi4bumXCI6XCJVXCIsXCLhu6dcIjpcInVcIixcIuG7qFwiOlwiVVwiLFwi4bupXCI6XCJ1XCIsXCLhu6pcIjpcIlVcIixcIuG7q1wiOlwidVwiLFwi4busXCI6XCJVXCIsXCLhu61cIjpcInVcIixcIuG7rlwiOlwiVVwiLFwi4buvXCI6XCJ1XCIsXCLhu7BcIjpcIlVcIixcIuG7sVwiOlwidVwiLFwi4buyXCI6XCJZXCIsXCLhu7NcIjpcInlcIixcIuG7tFwiOlwiWVwiLFwi4bu1XCI6XCJ5XCIsXCLhu7ZcIjpcIllcIixcIuG7t1wiOlwieVwiLFwi4bu4XCI6XCJZXCIsXCLhu7lcIjpcInlcIixcIuKAmFwiOlwiXFwnXCIsXCLigJlcIjpcIlxcJ1wiLFwi4oCcXCI6XCJcXFxcXFxcIlwiLFwi4oCdXCI6XCJcXFxcXFxcIlwiLFwi4oCgXCI6XCIrXCIsXCLigKJcIjpcIipcIixcIuKAplwiOlwiLi4uXCIsXCLigqBcIjpcImVjdVwiLFwi4oKiXCI6XCJjcnV6ZWlyb1wiLFwi4oKjXCI6XCJmcmVuY2ggZnJhbmNcIixcIuKCpFwiOlwibGlyYVwiLFwi4oKlXCI6XCJtaWxsXCIsXCLigqZcIjpcIm5haXJhXCIsXCLigqdcIjpcInBlc2V0YVwiLFwi4oKoXCI6XCJydXBlZVwiLFwi4oKpXCI6XCJ3b25cIixcIuKCqlwiOlwibmV3IHNoZXF1ZWxcIixcIuKCq1wiOlwiZG9uZ1wiLFwi4oKsXCI6XCJldXJvXCIsXCLigq1cIjpcImtpcFwiLFwi4oKuXCI6XCJ0dWdyaWtcIixcIuKCr1wiOlwiZHJhY2htYVwiLFwi4oKwXCI6XCJwZW5ueVwiLFwi4oKxXCI6XCJwZXNvXCIsXCLigrJcIjpcImd1YXJhbmlcIixcIuKCs1wiOlwiYXVzdHJhbFwiLFwi4oK0XCI6XCJocnl2bmlhXCIsXCLigrVcIjpcImNlZGlcIixcIuKCuFwiOlwia2F6YWtoc3RhbmkgdGVuZ2VcIixcIuKCuVwiOlwiaW5kaWFuIHJ1cGVlXCIsXCLigr1cIjpcInJ1c3NpYW4gcnVibGVcIixcIuKCv1wiOlwiYml0Y29pblwiLFwi4oSgXCI6XCJzbVwiLFwi4oSiXCI6XCJ0bVwiLFwi4oiCXCI6XCJkXCIsXCLiiIZcIjpcImRlbHRhXCIsXCLiiJFcIjpcInN1bVwiLFwi4oieXCI6XCJpbmZpbml0eVwiLFwi4pmlXCI6XCJsb3ZlXCIsXCLlhYNcIjpcInl1YW5cIixcIuWGhlwiOlwieWVuXCIsXCLvt7xcIjpcInJpYWxcIn0nKVxuICB2YXIgbG9jYWxlcyA9IEpTT04ucGFyc2UoJ3tcInZpXCI6e1wixJBcIjpcIkRcIixcIsSRXCI6XCJkXCJ9fScpXG5cbiAgZnVuY3Rpb24gcmVwbGFjZSAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NsdWdpZnk6IHN0cmluZyBhcmd1bWVudCBleHBlY3RlZCcpXG4gICAgfVxuXG4gICAgb3B0aW9ucyA9ICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgICA/IHtyZXBsYWNlbWVudDogb3B0aW9uc31cbiAgICAgIDogb3B0aW9ucyB8fCB7fVxuXG4gICAgdmFyIGxvY2FsZSA9IGxvY2FsZXNbb3B0aW9ucy5sb2NhbGVdIHx8IHt9XG5cbiAgICB2YXIgcmVwbGFjZW1lbnQgPSBvcHRpb25zLnJlcGxhY2VtZW50IHx8ICctJ1xuXG4gICAgdmFyIHNsdWcgPSBzdHJpbmcuc3BsaXQoJycpXG4gICAgICAvLyByZXBsYWNlIGNoYXJhY3RlcnMgYmFzZWQgb24gY2hhck1hcFxuICAgICAgLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBjaCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgKGxvY2FsZVtjaF0gfHwgY2hhck1hcFtjaF0gfHwgY2gpXG4gICAgICB9LCAnJylcbiAgICAgIC8vIHJlbW92ZSBub3QgYWxsb3dlZCBjaGFyYWN0ZXJzXG4gICAgICAucmVwbGFjZShvcHRpb25zLnJlbW92ZSB8fCAvW15cXHdcXHMkKl8rfi4oKSdcIiFcXC06QF0rL2csICcnKVxuICAgICAgLy8gdHJpbSBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlc1xuICAgICAgLnRyaW0oKVxuICAgICAgLy8gY29udmVydCBzcGFjZXMgdG8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG4gICAgICAvLyBhbHNvIHJlbW92ZSBkdXBsaWNhdGVzIG9mIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1tcXFxccycgKyByZXBsYWNlbWVudCArICddKycsICdnJyksIHJlcGxhY2VtZW50KVxuXG4gICAgaWYgKG9wdGlvbnMubG93ZXIpIHtcbiAgICAgIHNsdWcgPSBzbHVnLnRvTG93ZXJDYXNlKClcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIC8vIHJlbW92ZSBhbnl0aGluZyBiZXNpZGVzIGxldHRlcnMsIG51bWJlcnMsIGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhclxuICAgICAgc2x1ZyA9IHNsdWdcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cCgnW15hLXpBLVowLTknICsgcmVwbGFjZW1lbnQgKyAnXScsICdnJyksICcnKVxuICAgIH1cblxuICAgIHJldHVybiBzbHVnXG4gIH1cblxuICByZXBsYWNlLmV4dGVuZCA9IGZ1bmN0aW9uIChjdXN0b21NYXApIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gY3VzdG9tTWFwKSB7XG4gICAgICBjaGFyTWFwW2tleV0gPSBjdXN0b21NYXBba2V5XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXBsYWNlXG59KSlcbiIsIjxzY3JpcHQ+XG5pbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuXG5jb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuY29uc3Qga2V5Q29kZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAnTEVGVCc6IDM3LFxuICAgICdVUCc6IDM4LFxuICAgICdSSUdIVCc6IDM5LFxuICAgICdET1dOJzogNDBcbn0pO1xuXG5leHBvcnQgbGV0IGlkO1xuZXhwb3J0IGxldCBjaGVja2VkO1xuZXhwb3J0IGxldCBsYWJlbDtcblxuZnVuY3Rpb24gY2hlY2tTZWxlY3Rpb24obGFiZWwpIHtcblx0ZGlzcGF0Y2goJ2NoZWNrJywge2xhYmVsfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdGNhc2Uga2V5Q29kZXMuVVA6XG4gICAgICAgIGNhc2Uga2V5Q29kZXMuTEVGVDpcbiAgICAgICAgICAgIGRpc3BhdGNoKCdjaGVja1ByZXZpb3VzJywge2xhYmVsfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBrZXlDb2Rlcy5ET1dOOlxuICAgICAgICBjYXNlIGtleUNvZGVzLlJJR0hUOlxuICAgICAgICAgICAgZGlzcGF0Y2goJ2NoZWNrTmV4dCcsIHtsYWJlbH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG48L3NjcmlwdD5cblxuPGJ1dHRvbiBpZD1cIntpZH1cIiByb2xlPVwicmFkaW9cIiB0eXBlPVwiYnV0dG9uXCIgYXJpYS1jaGVja2VkPXtjaGVja2VkfSBjbGFzcz1cImJ1dHRvbiBidXR0b24tLXJhZGlvXCIgb246Y2xpY2s9eygpID0+IGNoZWNrU2VsZWN0aW9uKGxhYmVsKX0gb246a2V5ZG93bj17KGV2ZW50KSA9PiBoYW5kbGVLZXlEb3duKGV2ZW50KX0+XG5cdHtsYWJlbH1cbjwvYnV0dG9uPlxuXG48c3R5bGU+XG5idXR0b24ge1xuICAgIG1heC13aWR0aDogMTAwJTtcbn1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IHNsdWdpZnkgZnJvbSAnc2x1Z2lmeSc7XG5cbmV4cG9ydCBsZXQgb3B0aW9ucztcbmV4cG9ydCBsZXQgYWN0aXZlT3B0aW9uO1xuXG5jb25zdCBoYW5kbGVDaGVjayA9IHZhbHVlID0+IHtcblx0YWN0aXZlT3B0aW9uID0gdmFsdWU7XG59O1xuXG5jb25zdCBoYW5kbGVDaGVja1ByZXZpb3VzID0gdmFsdWUgPT4ge1xuXHRjb25zdCBjdXJyZW50SW5kZXggPSBvcHRpb25zLmluZGV4T2YodmFsdWUpO1xuXHRjb25zdCBuZXdJbmRleCA9IChjdXJyZW50SW5kZXggPT09IDApID8gb3B0aW9ucy5sZW5ndGggLSAxIDogY3VycmVudEluZGV4IC0gMTtcblx0Y29uc3QgbmV3QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2x1Z2lmeShvcHRpb25zW25ld0luZGV4XSwge2xvd2VyOiB0cnVlfSkpO1xuXHRuZXdCdXR0b24uZm9jdXMoKTtcblx0YWN0aXZlT3B0aW9uID0gb3B0aW9uc1tuZXdJbmRleF07XG59O1xuXG5jb25zdCBoYW5kbGVDaGVja05leHQgPSB2YWx1ZSA9PiB7XG5cdGNvbnN0IGN1cnJlbnRJbmRleCA9IG9wdGlvbnMuaW5kZXhPZih2YWx1ZSk7XG5cdGNvbnN0IG5ld0luZGV4ID0gKGN1cnJlbnRJbmRleCA9PT0gb3B0aW9ucy5sZW5ndGggLSAxKSA/IDAgOiBjdXJyZW50SW5kZXggKyAxO1xuXHRjb25zdCBuZXdCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzbHVnaWZ5KG9wdGlvbnNbbmV3SW5kZXhdLCB7bG93ZXI6IHRydWV9KSk7XG5cdG5ld0J1dHRvbi5mb2N1cygpO1xuXHRhY3RpdmVPcHRpb24gPSBvcHRpb25zW25ld0luZGV4XTtcbn1cblxuaW1wb3J0IFJhZGlvR3JvdXBCdXR0b24gZnJvbSAnLi9SYWRpb0dyb3VwQnV0dG9uLnN2ZWx0ZSc7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInJhZGlvLWdyb3VwXCI+XG5cdHsjZWFjaCBvcHRpb25zIGFzIG9wdGlvbn1cblx0PFJhZGlvR3JvdXBCdXR0b24gaWQ9e3NsdWdpZnkob3B0aW9uLCB7bG93ZXI6IHRydWV9KX0gY2hlY2tlZD17YWN0aXZlT3B0aW9uID09PSBvcHRpb24gPyAndHJ1ZScgOiAnZmFsc2UnfSBsYWJlbD17b3B0aW9ufSBvbjpjaGVjaz17KGV2ZW50KSA9PiBoYW5kbGVDaGVjayhldmVudC5kZXRhaWwubGFiZWwpfSBvbjpjaGVja1ByZXZpb3VzPXsoZXZlbnQpID0+IGhhbmRsZUNoZWNrUHJldmlvdXMoZXZlbnQuZGV0YWlsLmxhYmVsKX0gb246Y2hlY2tOZXh0PXsoZXZlbnQpID0+IGhhbmRsZUNoZWNrTmV4dChldmVudC5kZXRhaWwubGFiZWwpfSAvPlxuXHR7L2VhY2h9XG48L2Rpdj5cbiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxuXHRleHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlbG9hZCh7IHBhcmFtcywgcXVlcnkgfSkge1xuXHRcdGxldCB0b29scyA9IGF3YWl0IHRoaXMuZmV0Y2goYHRvb2xzLmpzb25gKTtcblx0XHR0b29scyA9IGF3YWl0IHRvb2xzLmpzb24oKTtcblxuXHRcdGxldCBuaWNoZXMgPSBhd2FpdCB0aGlzLmZldGNoKGBuaWNoZXMuanNvbmApO1xuXHRcdG5pY2hlcyA9IGF3YWl0IG5pY2hlcy5qc29uKCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9vbHMsXG5cdFx0XHRuaWNoZXNcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuXHRleHBvcnQgbGV0IHRvb2xzO1xuXHRleHBvcnQgbGV0IG5pY2hlcztcblxuXHRpbXBvcnQgQ2FyZCBmcm9tICcuLi9jb21wb25lbnRzL0NhcmQuc3ZlbHRlJztcblx0aW1wb3J0IFJhZGlvR3JvdXAgZnJvbSAnLi4vY29tcG9uZW50cy9SYWRpb0dyb3VwLnN2ZWx0ZSc7XG48L3NjcmlwdD5cblxuPHN2ZWx0ZTpoZWFkPlxuXHQ8dGl0bGU+Q28tb3AgVG9vbCBMaWJyYXJ5PC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlclwiPlxuXHQ8ZGl2IGNsYXNzPVwiaW5zaWRlXCI+XG5cdFx0PGgxPkNvb3BlcmF0aXZlIFRvb2wgTGlicmFyeTwvaDE+XG5cdFx0PHAgY2xhc3M9XCJzdWJoZWFkXCI+UHJhY3RpY2FsIHRvb2xzIGZvciBjby1vcHMuPC9wPlxuXHRcdDxkaXYgY2xhc3M9XCJjYWxscy10by1hY3Rpb25cIj5cblx0XHRcdDx1bD5cblx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdDxhIGhyZWY9XCIjdG9vbHNcIj5GaW5kIHByYWN0aWNhbCB0b29sczwvYT48YnI+XG5cdFx0XHRcdFx0Zm9yIHlvdXIgY28tb3Bcblx0XHRcdFx0PC9saT5cblx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdDxhIGhyZWY9XCIvZ2V0LXJlY29tbWVuZGF0aW9ucy9cIj5TZWUgb3RoZXIgY28tb3DigJlzIHRvb2xzPC9hPjxicj5cblx0XHRcdFx0XHRTZWUgb3RoZXIgY28tb3DigJlzIHRvb2xzXG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8YSBocmVmPVwiL3NoYXJlLXRvb2xzL1wiPlNoYXJlIHlvdXIgdG9vbHM8L2E+PGJyPlxuXHRcdFx0XHRcdHRvIGhlbHAgb3RoZXIgY28tb3BzIGZpbmQgdG9vbHNcblx0XHRcdFx0PC9saT5cblx0XHRcdDwvdWw+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuPC9kaXY+XG48ZGl2IGlkPVwidG9vbHNcIj5cblx0PGRpdiBjbGFzcz1cIm5pY2hlc1wiPlxuXHRcdDxoMz5GaW5kIHRvb2xzPC9oMz5cblx0XHQ8UmFkaW9Hcm91cCBvcHRpb25zPXtuaWNoZXN9IGFjdGl2ZU9wdGlvbj17J0FsbCd9IC8+XG5cdDwvZGl2PlxuXHQ8ZGl2IGNsYXNzPVwiY2FyZHNcIj5cblx0XHR7I2VhY2ggdG9vbHMgYXMgdG9vbH1cblx0XHRcdDwhLS0gd2UncmUgdXNpbmcgdGhlIG5vbi1zdGFuZGFyZCBgcmVsPXByZWZldGNoYCBhdHRyaWJ1dGUgdG9cblx0XHRcdFx0XHR0ZWxsIFNhcHBlciB0byBsb2FkIHRoZSBkYXRhIGZvciB0aGUgcGFnZSBhcyBzb29uIGFzXG5cdFx0XHRcdFx0dGhlIHVzZXIgaG92ZXJzIG92ZXIgdGhlIGxpbmsgb3IgdGFwcyBpdCwgaW5zdGVhZCBvZlxuXHRcdFx0XHRcdHdhaXRpbmcgZm9yIHRoZSAnY2xpY2snIGV2ZW50IC0tPlxuXHRcdFx0PENhcmQgdG9vbD17dG9vbH0gLz5cblx0XHR7L2VhY2h9XG5cdDwvZGl2PlxuPC9kaXY+XG4iXSwibmFtZXMiOlsidGhpcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkF1QmUsTUFBTSxDQUFDLElBQUksVUFBQyxHQUFJLElBQUMsTUFBTTs7OztnQ0FBNUIsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQUFDLE1BQU0sQ0FBQyxJQUFJLFVBQUMsR0FBSSxJQUFDLE1BQU07Ozs7K0JBQTVCLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBQUosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBQzhDLEdBQUksSUFBQyxNQUFNLFdBQUMsR0FBSyxLQUFFLEdBQUcsT0FBK0IsSUFBSSxDQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7OytEQUE5RCxHQUFJLElBQUMsTUFBTSxXQUFDLEdBQUssS0FBRSxHQUFHLE9BQStCLElBQUksQ0FBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBQTVHLEdBQUs7Ozt5QkFBTyxHQUFJLElBQUMsTUFBTSxXQUFDLEdBQUssS0FBRSxNQUFNLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhEQUF6QyxHQUFLOztnQkFBTyxHQUFJLElBQUMsTUFBTSxXQUFDLEdBQUssS0FBRSxNQUFNLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkFLckIsR0FBSSxJQUFDLFFBQVE7OzswQkFBSyxHQUFJLElBQUMsUUFBUSxHQUFHLENBQUMs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
